# 삽입 정렬

생성일: 2022년 7월 19일 오전 10:18
태그: java, python, 정렬

## 삽입 정렬이란?

브리지 게임을 할 때 사용되는 알로기즘은 한 번에 한 카드만 뽑아서 이미 살펴본 카드들 사이의 적합한 위치에 옮겨 넣는 것입니다. (이렇게 함으로써 정렬된 상태를 유지합니다.) 이것을 컴퓨터로 구현할 때는 항목을 삽입할 공간을 만들기 위해 삽입할 항목보다 큰 항목들을 전부 오른쪼긍로 밀어서 이동시켜야 합니다. 그다음에 확보된 공간에 항목을 삽입합니다.  이러한 방법을 구현한 것으로 삽입 정렬이라고 부릅니다.

선택 정렬과 마찬가지로 순회 중인 현재 인덱스의 왼쪽 편에 위치한 항목들은 정렬 과정 중에 정렬된 상태를 유지합니다. 하지만 최종 위치는 아니기 대문에 나중에 더 작은 항목이 발견되면 자리를 비켜 주어야 합니다. 배열 전체적으로 순회 인덱스가 오른쪽 끝에 다다랐을 때 완전히 정령된 상태가 됩니다.

## 삽입 정렬의 시간 복잡도

> 삽입 정렬은 중복 없는 키를 가진 무작위를 정렬된 크기 N의 배열에 대해 평균적으로 n^2 / 4번의 비교와 N^2 / 4번의 교환을 수행합니다. 최악의 조건에서는 N^2 / 2번의 교환과 N^2 / 2번의 비교를 수행하고, 최적 조건(이미 정렬된 배열)에서는 N - 1번의 비교와 0번의 교환을 수행합니다.
> 
- 삽입 정렬은 별도의 추가 공간을 사용하지 않고 주어진 배열이 차지 하고 있는 공간 내에서 값들의 위치만 바꾸기 때문에 O(1)의 공간 복잡도를 가집니다.
- 시간 복잡도는 우선 루프문을 통해 정렬 범위를 2개로 시작해서 전체로 확장해야 하기 때문에 기본적으로 O(N) 시간이 필요하게 됩니다. 따라서 삽입 정렬은 총 O(N^2)의 시간 복잡도를 가지는 정렬 알고리즘입니다.

## 삽입 정렬 구현

```java
public class InsertionSort {
    public static void sort(int[] arr) {
        for (int end = 1; end < arr.length; end++) {
            for (int i = end; i > 0; i--) {
                if (arr[i - 1] > arr[i])
                    swap(arr, i - 1, i);
            }
        }
    }

    private static void swap(int[] arr, int a, int b) {
        int tmp = arr[a];
        arr[a] = arr[b];
        arr[b] = tmp;
    }
}
```

```python
def insertion_sort(arr):
    for end in range(1, len(arr)):
        for i in range(end, 0, -1):
            if arr[i - 1] > arr[i]:
                arr[i - 1], arr[i] = arr[i], arr[i - 1]
```